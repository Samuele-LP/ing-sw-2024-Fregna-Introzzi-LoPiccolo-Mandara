package it.polimi.ingsw.network.server;

import it.polimi.ingsw.ConstantValues;
import it.polimi.ingsw.controller.ClientController;
import it.polimi.ingsw.controller.ServerSideMessageListener;
import it.polimi.ingsw.network.messages.Pong;
import it.polimi.ingsw.network.messages.ServerToClientMessage;

import java.io.IOException;
import java.rmi.NoSuchObjectException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.util.LinkedList;
import java.util.concurrent.TimeUnit;

/**
 * The ClientHandlerRmi class manages the interaction between the server and a single client
 * using RMI (Remote Method Invocation). It handles receiving, processing, and sending messages to the client.
 */
public class ClientHandlerRmi extends ClientHandler {

    /**
     * The ClientController used for the connection.
     */
    private final ClientController clientController;

    /**
     * The ServerSideMessageListener used to receive messages on the server side.
     */
    private final ServerSideMessageListener gameListener;

    /**
     * The queue of messages to be sent to the client.
     */
    private final LinkedList<ServerToClientMessage> messageQueue = new LinkedList<>();

    /**
     * Flag indicating whether the connection is still active.
     */
    private boolean connectionActive = true;

    /**
     * Flag indicating whether a Pong message has been received.
     */
    private boolean receivedPong = false;

    /**
     * Constructs a ClientHandlerRmi to handle client interactions using RMI.
     *
     * @param clientController the controller needed to handle the client.
     * @param gameListener the listener needed to receive messages on the server side.
     */
    protected ClientHandlerRmi(ClientController clientController, ServerSideMessageListener gameListener) {
        this.clientController = clientController;
        this.gameListener = gameListener;
    }

    /**
     * The client handler is notified of a ping reception and sends a Pong as a response.
     *
     * @throws IOException if an error occurs while trying to send a Pong message.
     */
    @Override
    public void pingWasReceived() {
        try {
            sendMessage(new Pong());
        } catch (IOException e) {
            System.err.println("IOException while sending Pong: " + e.getMessage());
            stopConnection();
        }
    }

    /**
     * Sends a message to the client.
     *
     * @param mes the message generated by the controller.
     * @throws RemoteException if there is an error during the remote method call.
     */
    @Override
    public void sendMessage(ServerToClientMessage mes) throws RemoteException {
        clientController.handle(mes);
    }

    /**
     * Method to read incoming messages. This method runs indefinitely as a thread until the connection is closed.
     */
    @Override
    public void receiveMessage() {
        // No implementation needed, messages are received via RMI calls
    }

    /**
     * Runs indefinitely as a thread to pass messages to the client and handle them until the connection is closed.
     */
    @Override
    public void passMessage() {
        while (connectionActive) {
            synchronized (messageQueue) {
                if (!messageQueue.isEmpty()) {
                    ServerToClientMessage message = messageQueue.pop();
                    clientController.handle(message);
                }
            }
        }
    }

    /**
     * Ends the connection between the server and this client handler.
     */
    public void stopConnection() {
        connectionActive = false;
        try {
            UnicastRemoteObject.unexportObject((Remote) clientController, true);
        } catch (NoSuchObjectException e) {
            System.out.println("Error while unexporting the remote object: " + e.getMessage());
        }
    }

    /**
     * Sends a message to the client.
     *
     * @param message the message to be sent to the client.
     * @throws RemoteException if there is an error during the remote method call.
     */
    public synchronized void sendToClient(ServerToClientMessage message) throws RemoteException {
        clientController.handle(message);
    }

    /**
     * The listener is notified when a Pong is received.
     */
    public void pongWasReceived() {
        receivedPong = true;
    }

    /**
     * Periodically checks if a Pong has been received. If not received within the timeout period,
     * the connection is closed.
     */
    public void checkConnectionStatus() {
        while (connectionActive) {
            try {
                for (int i = 0; i < ConstantValues.connectionTimeout_seconds; i++) {
                    TimeUnit.SECONDS.sleep(1);
                }
            } catch (InterruptedException e) {
                System.err.println("InterruptedException while waiting for a Pong");
                throw new RuntimeException(e);
            }

            if (!receivedPong) {
                this.stopConnection();
            } else {
                receivedPong = false;
            }
        }
    }
}