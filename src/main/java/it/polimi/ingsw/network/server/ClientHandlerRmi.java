package it.polimi.ingsw.network.server;

import it.polimi.ingsw.ConstantValues;
import it.polimi.ingsw.controller.ClientController;
import it.polimi.ingsw.controller.ServerSideMessageListener;
import it.polimi.ingsw.network.messages.Pong;
import it.polimi.ingsw.network.messages.ServerToClientMessage;

import java.io.IOException;
import java.rmi.NoSuchObjectException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.util.LinkedList;
import java.util.concurrent.TimeUnit;

public class ClientHandlerRmi extends ClientHandler {

    /**
     * ClientController used for the connection
     */
    private final ClientController clientController;

    /**
     * ServerSideMessageListener used to receive messages server side
     */
    private final ServerSideMessageListener gameListener;

    /**
     * List of ServerToClientMessage used to pass messages to client
     */
    private final LinkedList<ServerToClientMessage> messageQueue = new LinkedList<>();

    /**
     * Flag to know if the connection is still alive
     */
    private boolean connectionActive = true;

    /**
     * Flag to know if pong is received
     */
    private boolean receivedPong = false;

    /**
     * Starts RMI Client Handler
     *
     * @param clientController needed to handle client
     * @param gameListener needed to listen for messages server side
     */
    protected ClientHandlerRmi(ClientController clientController, ServerSideMessageListener gameListener) {
        this.clientController = clientController;
        this.gameListener = gameListener;
    }

    /**
     * The client handler is notified of a ping reception and sends a Pong as a response
     *
     * @throws IOException if an error occurs while trying to send a pong message
     */
    @Override
    public void pingWasReceived() {
        try {
            sendMessage(new Pong());
        } catch (IOException e) {
            System.err.println("IOException while sending Pong: " + e.getMessage());
            stopConnection();
        }
    }

    /**
     * Sends a message to the client
     *
     * @param mes is the message generated by the controller
     */
    @Override
    public void sendMessage(ServerToClientMessage mes) throws RemoteException {
        clientController.handle(mes);
    }

    /**
     * Method used to read incoming messages, runs indefinitely as a thread until the connection is closed.
     */
    @Override
    public void receiveMessage() {
        // No implementation needed, messages are received via RMI calls
    }

    /**
     * Runs indefinitely as a thread to pass messages onto the client and handle them until the connection is closed.
     */
    @Override
    public void passMessage() {
        while (connectionActive) {
            synchronized (messageQueue) {
                if (!messageQueue.isEmpty()) {
                    ServerToClientMessage message = messageQueue.pop();
                    clientController.handle(message);
                }
            }
        }
    }

    /**
     * Ends the connection between the server and this client handler
     *
     * @throws NoSuchObjectException if the clientController is empty
     */
    public void stopConnection() {
        connectionActive = false;
        try {
            UnicastRemoteObject.unexportObject((Remote) clientController, true);
        } catch (NoSuchObjectException e) {
            System.out.println("Error while unexporting the remote object: " + e.getMessage());
        }
    }

    /**
     * Sends a message to the client
     *
     * @throws RemoteException if there is an invalid remote object in ServerToClientMessage
     */
    public synchronized void sendToClient(ServerToClientMessage message) throws RemoteException {
        clientController.handle(message);
    }

    /**
     * The listener who has been passed a pong will notify the connection
     */
    public void pongWasReceived() {
        receivedPong = true;
    }

    /**
     * Every timeout period checks if a Pong has been received.
     * If a Pong has not been received for enough time then the connection will be closed
     *
     * @throws InterruptedException if the connection gets interrupted while waiting for a pong
     */
    public void checkConnectionStatus() {
        while (connectionActive) {
            try {
                for (int i = 0; i < ConstantValues.connectionTimeout_seconds; i++) {
                    TimeUnit.SECONDS.sleep(1);
                }
            } catch (InterruptedException e) {
                System.err.println("InterruptedException while waiting for a Pong");
                throw new RuntimeException(e);
            }

            if (!receivedPong) {
                this.stopConnection();
            } else {
                receivedPong = false;
            }
        }
    }
}