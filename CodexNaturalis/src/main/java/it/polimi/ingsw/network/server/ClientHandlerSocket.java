package it.polimi.ingsw.network.server;

import it.polimi.ingsw.controller.GameController;
import it.polimi.ingsw.controller.ServerSideMessageListener;
import it.polimi.ingsw.ConstantValues;
import it.polimi.ingsw.network.messages.ClientToServerMessage;
import it.polimi.ingsw.network.messages.Message;
import it.polimi.ingsw.network.messages.Pong;
import it.polimi.ingsw.network.messages.ServerToClientMessage;
import it.polimi.ingsw.network.messages.serverToClient.GenericMessage;


import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.TimeUnit;

import static it.polimi.ingsw.ConstantValues.maxMessagesInQueue;

public class ClientHandlerSocket extends ClientHandler {

    /**
     * Debugging: name of this class
     */
    String className = ClientHandlerSocket.class.getName();

    /**
     * ServerSideMessageListener of the related game
     */
    private final ServerSideMessageListener serverSideMessageListener = GameController.getInstance();

    /**
     * ObjectInputStream in
     */
    private final ObjectInputStream in;

    /**
     * ObjectOutputStream out
     */
    private final ObjectOutputStream out;

    /**
     * Client Socket, unchangeable
     */
    private final Socket clientSocket;
    private boolean receivedPing = false;
    private final Object pingLock = new Object();

    /**
     * Create a queue for messages that can take up to maxMessagesInQueue messages.
     * NB: not more than maxMessagesInQueue in order to limit the spam ability of clients
     */
    private final ArrayBlockingQueue<ClientToServerMessage> queue = new ArrayBlockingQueue<>(maxMessagesInQueue);

    /**
     * Used to handle Client needs
     */
    public ClientHandlerSocket(Socket clientSocket) throws IOException {
        this.clientSocket = clientSocket;
        this.out = new ObjectOutputStream(clientSocket.getOutputStream());
        this.in = new ObjectInputStream(clientSocket.getInputStream());
    }

    /**
     * Receive messages by client to server
     */
    public void receiveMessage() {
        try {
            ClientToServerMessage message;
            while (!this.isInterrupted()) {
                message = (ClientToServerMessage) in.readObject();
                queue.add(message);
            }
        } catch (ClassNotFoundException classNotFoundException) {
            System.out.print("\n\n!!! Error !!! (" + className + new Exception().getStackTrace()[0].getLineNumber() + ") Failed for some reasons!\n\n");
        } catch (IllegalStateException illegalStateException) {
            System.out.print("\n\n!!! Error !!! (" + className + new Exception().getStackTrace()[0].getLineNumber() + ") Client is spamming messages!\n\n");
        } catch (IOException e) {
            System.out.print("\n\n!!! Disconnection detected !!! IOException while receiving messages!\n\n");
            serverSideMessageListener.disconnectionHappened(this);
        } catch (ClassCastException castException) {
            System.out.println("\n\nA client sent an invalid object!\n\n");
            synchronized (this) {

                try {
                    out.writeObject(new GenericMessage("An invalid object was received by the server"));
                } catch (IOException ioException) {
                    System.err.println("\n\nError while sending a generic response to the client\n\n");
                    serverSideMessageListener.disconnectionHappened(this);
                }

            }
        }
    }

    /**
     * Sends messages by client to server
     */
    public void passMessage() {
        try {
            Message message;
            while (!this.isInterrupted()) {
                message = null;
                //NB: ".take()" with an ArrayBlockingQueue does the following:
                //Retrieves and removes the head of this queue, waiting if necessary until an element becomes available.
                message = (Message) queue.take();
                ClientToServerMessage clientToServerMessage = (ClientToServerMessage) message;
                clientToServerMessage.execute(this.serverSideMessageListener, this);
            }
        } catch (InterruptedException e) {
            System.out.print("\n\n!!! Error !!! (" + className + new Exception().getStackTrace()[0].getLineNumber() + ") Unable to pass message to Server!\n\n");
            throw new RuntimeException(e);
        }
    }

    /**
     * Interrupt the thread
     */
    public void interruptSelf() {
        this.interrupt();
    }

    /**
     * Method used for debugging. It prints the number of elements that are inside the queue
     */
    private void printQueueNumberOfElements() {
        System.out.println("Elements in queue: " + queue.size());
    }

    /**
     * Sends a message to the client
     *
     * @param mes is the message generated by the controller
     * @throws IOException if there are problems sending the message
     */
    public synchronized void sendMessage(ServerToClientMessage mes)  throws IOException{
            out.writeObject(mes);
    }

    /**
     * The client handler is notified of a ping reception and sends a Pong as a response
     */
    public void pingWasReceived() {
        synchronized (pingLock) {
            receivedPing = true;
        }
        synchronized (this) {
            try {
                out.writeObject(new Pong());
            } catch (IOException e) {
                System.err.println("\n\nAn error has occurred while sending a Pong response\n\n");
            }
        }
    }

    /**
     * Every timeout period
     */
    public void checkConnectionStatus() {
        while (!clientSocket.isClosed()) {
            try {
                TimeUnit.SECONDS.sleep(ConstantValues.connectionTimeout_seconds);
            } catch (InterruptedException e) {
                System.err.println("InterruptedException while waiting for a Pong");
                throw new RuntimeException(e);
            }
            synchronized (pingLock) {
                if (!receivedPing) {
                    serverSideMessageListener.disconnectionHappened(this);
                } else {
                    receivedPing = false;
                }
            }
        }
    }

    /**
     * Ends the connection between client and server
     */
    public void stopConnection() {
        if(clientSocket.isClosed()){
            return;
        }
        try {
            out.close();
            in.close();
            clientSocket.close();
        } catch (IOException e) {
            System.err.println("Error while terminating a connection to" + clientSocket.getInetAddress().toString());
        }
    }
}