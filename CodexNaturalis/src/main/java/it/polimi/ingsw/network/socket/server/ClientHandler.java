package it.polimi.ingsw.network.socket.server;

import it.polimi.ingsw.controller.ServerSideMessageListener;
import it.polimi.ingsw.network.messages.ClientToServerMessage;
import it.polimi.ingsw.network.messages.Message;
import it.polimi.ingsw.network.messages.ServerToClientMessage;


import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.Socket;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentLinkedQueue;

import static it.polimi.ingsw.network.commonData.ConstantValues.maxMessagesInQueue;

public class ClientHandler extends Thread {

    /**
     * Debugging: name of this class
     */
    String className = ClientHandler.class.getName();

    /**
     * Flag to now if this is the player turn
     */
    private boolean isPlaying = false;

    /**
     * ServerSideMessageListener of the related game
     */
    private ServerSideMessageListener serverSideMessageListener;

    /**
     * ObjectInputStream in
     */
    private ObjectInputStream in;

    /**
     * ObjectOutputStream out
     */
    private ObjectOutputStream out;

    /**
     * AudiencesHandlerServerSide of the related Game
     */
    //private AudiencesHandlerServerSide audiencesHandlerServerSide;

    /**
     * Client Socket, unchangeable
     */
    private final Socket clientSocket;

    /**
     * Create a queue for messages that can take up to maxMessagesInQueue messages.
     * NB: not more than maxMessagesInQueue in order to limit the spam ability of clients
     */
    private ArrayBlockingQueue<ClientToServerMessage> queue = new ArrayBlockingQueue<>(maxMessagesInQueue);
    //OPPURE USARE UNA CONCURRENTLINKEDQUEUE !?!?!?!?!?


    /**
     * Used to handle Client needs
     *
     * @param clientSocket
     * @throws IOException
     */
    public ClientHandler(Socket clientSocket) throws IOException {
        this.clientSocket = clientSocket;
        this.in = new ObjectInputStream(clientSocket.getInputStream());
        this.out = new ObjectOutputStream(clientSocket.getOutputStream());
       // AudiencesHandlerServerSide audiencesHandlerServerSide = new AudiencesHandlerServerSide();
    }

    /**
     * Receive messages by client to server
     */
    public void receiveMessage(){
        //Thread tmp_thread = new Thread(this);
        //tmp_thread.start();

        // THREADS DA SPOSTARE IN CLIENTSOCKET

        try{
            ClientToServerMessage message;
            while(!this.isInterrupted()){
                message = (ClientToServerMessage) in.readObject();
                queue.add(message);
            }
        } catch(IOException | ClassNotFoundException e0){
            System.out.print("\n\n!!! Error !!! (" + className + new Exception().getStackTrace()[0].getLineNumber() + ") Failed for some reasons!\n\n");
        } catch(IllegalStateException e1){
            System.out.print("\n\n!!! Error !!! (" + className + new Exception().getStackTrace()[0].getLineNumber() + ") Client is spamming messages!\n\n");
        }finally{
            //tmp_thread.interrupt();
        }
    }

    /**
     * Sends messages by client to server
     */
    public void passMessage(){
        //Thread tmp_thread = new Thread(this);
        //tmp_thread.start();

        // THREADS DA SPOSTARE IN CLIENTSOCKET

        try{
            Message message;
            while(!this.isInterrupted()){
                message = null;
                //NB: ".take()" with an ArrayBlockingQueue does the following:
                //Retrieves and removes the head of this queue, waiting if necessary until an element becomes available.
                message = (Message) queue.take();
                ClientToServerMessage clientToServerMessage = (ClientToServerMessage) message;
                clientToServerMessage.execute(this.serverSideMessageListener, this);
            }
        } catch (InterruptedException e) {
            System.out.print("\n\n!!! Error !!! (" + className + new Exception().getStackTrace()[0].getLineNumber() + ") Unable to pass message to Server!\n\n");
            throw new RuntimeException(e);
        } finally {
            //tmp_thread.interrupt();
        }
    }

    /**
     * Interrupt the thread
     */
    public void interruptSelf(){
        this.interrupt();
    }

    /**
     * Method used for debugging. It prints the number of elements that are inside the queue
     */
    private void printQueueNumberOfElements(){
        System.out.println("Elements in queue: " + queue.size());
    }

    /**
     * Sends a message to the client
     * @param mes is the message generated by the controller
     * @throws IOException if there are problems sending the message
     */
    public synchronized void sendMessage(ServerToClientMessage mes) throws IOException {
        out.writeObject(mes);
    }
}